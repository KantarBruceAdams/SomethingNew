*Selections from the initial email thread (in response to the VPRI "Fonc" email-list being decommissioned) which spurred the creation of this collaboration / initiative.*

----

Kim Rose
<br/>24 July 2017

Dear "fonc" community,

This is to notify you that this mailing list ("fonc") will be retired and made inactive at the end of this month.
<br/>VPRIs focus and efforts have shifted and we will no longer host or support this list.
<br/>Thanks for your past interest, support and participation.

Kim Rose
<br/>Viewpoints Research Institute

Fonc mailing list
<br/>Fonc@mailman.vpri.org
<br/>http://mailman.vpri.org/mailman/listinfo/fonc_mailman.vpri.org

----

Kim Rose
<br/>24 July 2017

No, sorry…..I suppose if someone in the community wanted to start something up they’d be more than welcome.  Activity had dropped to almost nothing in the past year…..

> On 25 July 2017, Andrey Fedorov wrote:
>
> How unfortunate! Is there at least a Slack channel to replace it?

----

Dave Crossland
<br/>24 July 2017

Hi

> On 24 July 2017, Kenny Friedman wrote:
>
> Even with the low volume output, the occasional postings (and people on this list) can still be a valuable resource.
> <br/>If people are willing, I will happily host this mailing list at MIT (email is free, and will last... far longer than Slack).
> <br/>In fact, I have already set up the mailing list: fonclist@mit.edu . (It runs on the same mailman system this previous list runs on)
> <br/>You can subscribe to the new FONC list, hosted at MIT, here: http://mailman.mit.edu/mailman/listinfo/fonclist

Brilliant, thank you Kenny!

Kim, is there a similar way to keep in touch with the latest developments of VPRI and HARC?

----

Joel Jakubovic
<br/>29 July 2017

You leave the rather intriguing comment that

> VPRIs focus and efforts have shifted and we will no longer host or support this list.

What have the focus and efforts of VPRI shifted to? Is this related to the
<br/>completion of the STEPS project or is that old news?

I only found out about FoNC, VPRI, heck even the untold story of OOP, less
<br/>than a year ago, and the stuff you're all working on is incredible. It's
<br/>pretty criminal how little-known it is, but I joined because I believe in
<br/>what you're doing and want to see what's going on.

It's a shame that there's not been much activity in 2016 and 17 - but from
<br/>my limited expeditions into the depths of the archives, there seems to be
<br/>a real wealth of useful info that isn't present anywhere else. So huge
<br/>thanks to Kenny Friedman for setting up the new list and archive mirror;
<br/>it'd be a bit sad to join a group just as it's about to disband! :)

----

Yoshiki Ohshima
<br/>29 July 2017

There will be some more news in the near future, but I can tell you
<br/>that many of us moved to a Lab called Communications Design Group and
<br/>then to HARC at Y Combinator Research.  Yes, the focus had shifted
<br/>that these points.

----

Eugene Wallingford
<br/>29 July 2017

The web home is: http://harc.ycr.org  The set of researchers
<br/>is impressive and interesting.  I'm familiar with the GP
<br/>project, and several others are worth of a deeper looker.
<br/>I'm especially interested in the tutoring system.

----

Dan Cook
<br/>29 July 2017

Hi all,

Over the last 4 years, I too have stumbled upon "the untold story of oop", VPRI, and a number of other "untold" histories of software and efforts to make it more open-ended & human-oriented. I can tell you that FONC is not the only attempt at such a thing.

If I'm not the only one, maybe we can benefit from sharing what we've found (or collaborate on projects or ideas or resources), rather than just limiting to the COLA stuff.

I myself have taken from many sources (like the ones listed below) to develop my own user-oriented software innovation

Is anyone interested?

Examples:
- Intentional Domain Workbench,
- Meta Programming System,
- Lively Kernel,
- https://youtu.be/1O8PwkXfDJg
- (and the following are all on worrydream.com)
  - The Humane Representation of Thought,
  - Drawing Dynamic Visualizations,
  - Learnable Programming

----

Joel Jakubovic
<br/>30 July 2017

Interested? Absolutely. I recognise the Lively Kernel, and I found Bret
<br/>Victor shortly after discovering this place. But I hadn't come across the
<br/>other things you mentioned; thanks for those.

I was really pleased to see the Apparatus Editor thing (aprt.us) at the
<br/>HARC website. Previously, it was really frustrating that Bret Victor's
<br/>array of magic tools existed only in his talks, but now there is an online
<br/>implementation to play with and study. And the rest of the projects seem
<br/>to be the continuation of several VPRI threads, which is reassuring to
<br/>see.

I agree with you about discussing more than just the COLAs. Are there
<br/>rules for the discussion group about what the focus is? (I haven't
<br/>participated in a mailing list before, so I apologise if I'm making rookie
<br/>mistakes as to the form or content of my replies - please tell me if
<br/>anything's wrong!)

> I can tell you that FONC is not the only attempt at such a thing.

VPRI, or soon-to-be HARC, does seem to be the only organised body of
<br/>people working on this stuff though - I assume that's what you were
<br/>talking about? What little else I've seen is the work of individuals like
<br/>Bret Victor, or the person in the talk you linked to.

By the way, I think I must have come across your GitHub account a few
<br/>weeks ago - I was looking at https://github.com/d-cook/Objects, and I've
<br/>been feeling the urge to do something similar. I think I have the same end
<br/>goal (don't we all), but instead of bootstrapping from JavaScript, I want
<br/>to start with an empty OS process, and hopefully have some sort of
<br/>self-modifying visual editor.

In the same way that the Piumarta and Warth devised the Id object model to
<br/>be the 'minimal' generator, so to speak, of an OO system, why not consider
<br/>the question of what the minimal generator for *direct manipulation* would
<br/>look like - in contrast to the traditional boostrapping method of
<br/>developing textual languages. I want to *begin* with direct manipulation
<br/>of memory and machine instructions, as early as possible -  rather than
<br/>starting with textual programming languages and parsing, adding direct
<br/>manipulation later.  I'd just find it more pleasant to implement the
<br/>object model in a more visually-aided way. What do you think?

Finally, I just wanted to mention the ominous message on the FONC wiki:

> We are faced with a need for significant action and the odds are stacked
> <br/>against us. Invention receives no attention, and innovation (even when
> <br/>incorrectly understood) receives lip service in the press but no
> <br/>current-day vehicle exists to to nurture it.

I suppose I can always go back to this whenever I need a chill down the
<br/>spine and a sense of pressing urgency in life! Anyone else wonder if, at
<br/>some point in the future, society will be so dependent on computer
<br/>software ... that some random null pointer dereference will bring down the
<br/>entirety of civilisation?

----

Dan Cook
<br/>31 July 2017

First things first: I suggest we find a place to host collaborative materials and discussion. It's probably more important to have somewhere soon than to have somewhat perfect (we can fix that later)

Siggestions:
- google hangouts
- google groups
- github
- cemetech.net (might seem like an odd target community, but there are many creative minds there, exploring all kinds of topics)

One thing I'd like is a list of goals, motivations, and means or mechanisms, and from there we can see where our ideas & materials overlap or differ, and perhaps refine how to approach these things better. Also of value may be what else we can do to promote new ideas and ways of thinking (& doing) in the larger community (industry, education, organizations). I've been trying to promote a subset of ideas at work, but it's hard for most developers to think outside of their mechanical (rather than humanistic) view of software. I'm having some luck appealing to the User Experience (UX) team though, so we'll see where that goes.

In response to some questions I've had:

I agree about promoting the user model above (or instead of) a textual one. My bootstrap approach is a means to create an underlying execution model that could change itself and later be subsumed by a UI. I was going to forego parsing and a REPL and just "brute force" a UI that will allow further development to be done visually; but since I'm starting with code, I'm having a hard time feeling like those things wouldn't make my life easier just to GET to that point.

On the other hand, I've found an applicable reason for such a tool at work, for which I'm STARTING with the UI, and may drill down into the underlying code from there. (It's drag & drop composition of software, like Bret Victor's "Drawing Dynamic Visualizations", but with functions & data instead of graphical shapes). I expect both models to "meet" at some point in the middle.

I fully agree with the need to implement a system at the lowest level possible, but I've started in JavaScript because it will give me a fast POC, and because I believe that the code within such a system MUST be homoiconic, like Lisp. (JavaScript is not, but it gives me ad-hoc lists and objects for free). Plus, I can just pop open any browser and BOOM. But yes, ultimately I want a system to run on the metal.

There is more I could say, but let's find a better place to collaborate first

----

Dan Cook
<br/>14 October 14 2017

Following the announcement that the VPRI FONC list would be discontinued,  some of you expressed interest in collaborating related projects & ideas.

To that end (and in response to some further discussion I've had with some of you), I've created the following GitHub project as a place to collect & document various ideas, concepts, goals, resources, and projects:

https://github.com/d-cook/SomethingNew

The idea is to combine our thoughts, efforts, and resources in the hopes of either (1) finding a common goal/project and collaborating to make something better than an individual effort would yield, and/or (2) supplementing our own individual pursuits by building on each other's ideas and works. One main idea is to explore multiple avenues (projects) at once, rather than trying to find or define "the one best way". This applies both to separate projects or ideas, and exploring (branching) common projects / ideas to explore multiple possibilities.

Currently, the content is rather sloppy and comes from scraping thoughts & goals from some discussion I've had here, and from my own project(s); but I plan to refine it (my aim to is to "get it all out there" first, and then refine it into smaller more coherent main ideas later). I plan to add a bunch of links to related resources shortly, so watch for that. ANYONE IS WELCOME TO FREELY CONTRIBUTE. Since it's a GitHub "project", it has history of all changes, so should the case arise that we disagree with the format or content, we can always review and discuss it; and I mention this as a way to encourage you to be fearless in adding or refining anything present.

I have high hopes for what we can achieve & share together, and for this GitHub project page as a more transparent & clear way (moreso than an email list) to do that.

----

Brendan G Bohannon
<br/>15 October 2017

Not sure if relevant, but a few things I had worked on in the past few years.

I have ended up focusing a lot more on the technical side of things than the user-facing side of things, so, yeah, maybe not all that relevant.

BGBTech2: ... a 3D engine ...
<br/>https://cr88192.github.io/bgbtech_html/deeptail0.html

BGBScript2: a language originally meant for some personal embedded/robot projects ...
<br/>https://github.com/cr88192/bgbtech_engine2/wiki/BGBScript2-1

(I have some robotics stuff, but would prefer to keep a lot of this code private, and the code isn't likely to be terribly useful).

Codecs: BTIC1H and BTIC4B, mostly low-complexity image/video codecs ...

BGBCC: ... an old C compiler of mine ... a previous version targeted a VM used in my robot projects (which BGBScript2 was intended to replace) ...

BJX1: ... sort of a custom ISA, mostly based on an extended form of the SH4 ISA (Hitachi SuperH)
<br/>https://github.com/cr88192/bgbtech_shxemu/wiki/SH-BJX1-ISA
<br/>https://github.com/cr88192/bgbtech_shxemu/wiki/BJX1_IsaDesc

...

Would be nice is CPUs were more open though, like if there were more freedom for people to tinker and customize stuff (vs always treating them as black boxes controlled by some central authority).

There is also RISC-V, which seems promising, but I haven't looked into it all that too deeply.

----

Dan Cook
<br/>16 October 2017

... It is pretty awesome that you're making custom hardware to solve software problems, so thanks for sharing!

Anyway, **while I do want to be liberal about what is shared, I want to limit it to reinventing software (and hardware) to enable fundamentally new ways of thinking and doing**; the computer revolution that "hasn't happened yet", as Kay says. (TODO: Need to add a similar statement to the SomethingNew readme)

However, it might be beneficial to see everyone's past/present projects. I wonder if it would be beneficial to create somewhat of a profile page (or link to one) for each person, even if very informal and brief (e.g. stated interest, experience, and list of projects or whatever). ... though perhaps that's redundant, since we can already view each other's github accounts to see bio & personal projects. But maybe that's also not the same; but I do want to keep the collaboration material related to the main (or related) initiative(s).

----

Dan Cook
<br/>16 October 2017

Hi all,

Joel had some good questions about this collaboration and the "SomethingNew" GitHub project, and since our discussion was quite relevant, I'm sharing it (with his permission) with the rest of you, below:

[Dan] That's a great looking Blog; and I'm very interested in what you have to say (assuming that's all yours?) in that "Language isn't everything" entry (will read later). **I think it's great for anyone to keep up their own personal stuff (projects, blogs, etc.), and we can talk about the best way to link to our personal stuff**. Perhaps it would be good to create a new page with links to forum topics or blogs (or blog entries) that are relevant, or upon which we are discussion some of these things. And/or maybe we can create an ad-hoc forum (a folder, and each file in it being an ongoing discussion. The change-history will show who contributed what & when, and any edits)

[Dan] As to be a Fonc successor ... I guess that's arguably true. I mean, the mail-list is certainly where the people are originating from; but whether it's "that" or a different "thing" that was spurred from it ... I don't know which is technically accurate, or what we should or should not claim (I mean, I am not Fonc or VPRI; but arguable "we" are? I don't know) ... But whatever, it is what it is, and I just care about making this current thing a "thing". Maybe it's best to not claim another other than that we came together from the Fonc mailing-list.

> [Joel] By the way, I worry about accidental plagiarism on my part, which is one
> reason I've been avoiding reading your code, as if it were some sort of
> patent. But as Alan Kay once said, something like (can't find the quote):
> it's better to collaborate to achieve great things rather than trying to
> decide who did what first etc. So it's probably a silly thing to worry
> about right? (Forgive my naiveté -- I'm fresh out of university.)

[Dan] It's not silly to worry about that in general; but yes, **my main goal is to make things happen, and sharing openly is the best (and perhaps only) way to get something big and meaningful to happen** (I actually made a statement about this on my very first post on the topic at Cemetech: https://www.cemetech.net/forum/viewtopic.php?t=11080). We can worry about legal stuff if this goes anywhere big, and even then I'd prefer to make that bubble as inclusive as makes sense. But I think we are a long ways out from that point, and until then, I hope we can all feel free to borrow & share liberally from each other to the end of making something work.

[Dan] Fresh out of University ... Excellent! That means (1) You are the right person for this, if you're this interested/involved at this point (nice blog!), and (2) Less preconcieved ideas or stuff that you have to unlearn. I tell you, it's been a pain (and almost a lost cause) to try to discuss any truly "new" stuff with any of my more seasoned (I'm a Software Engineer of 5 years now), because they've already got it "figured out", or are content with their perception of their field, and not interested in challenging it.

> [Joel] Finally, we might want to think about a name for the mission as a whole,
> for convenience. Like FoNC. No ideas from me yet though.

[Dan] Maybe. I don't know how I feel about claiming to be "Fonc" (though it's discontinued). "Worse is Better", so I just called it something at all (SomethingNew) ... If this goes anywhere meaningful, this will be something more important to discuss. 

> [Joel] Once again, thanks for taking the initiative here. I look forward to being
> a part of this; it feels extremely important, though sadly unknown.

[Dan] Hopefully, we can work together to convert a lot of thinking into doing. Though an explosion of thought is probably on the menu to start with (and going forward), and that's one of the main goals. Let's see what our combined heads can do to find the "pink plane" (and "pink thoughts") as possible (see ... almost any of Alan Kay's videos on YouTube for the reference. Look for "New" vs "News").

----

Jecel Assumpcao Jr.
<br/>17 October 2017

Dan,

In the past there have been projects that have attracted people with
similar ideas and ended up with interesting discussions even if the
groups efforts were never combined into a single project. That was
certainly the case for Tunes OS, which is still a source of related
information:

http://tunes.org/cliki/

A wiki or a shared document on Github is a great way to accumulate
information in a way that can be accessed by new people joining the
project, but it should be complemented by a mailing list or something
like Slashdot or Hacker News, with the best example being:

http://lambda-the-ultimate.org/

----

Dan Cook
<br/>28 October 2017

I have pasted selections of these emails to the https://github.com/d-cook/SomethingNew/ project (see the "Discussion" links on the ReadMe page, which is immediately visible on the project home page).

I have exchanged a LOT of valuable information & insights here, and it's a shame to let it get lost in emails.

I'm hoping that we can move forward by contributing information directly to topics / lists / etc. that anyone can easily find or expand upon, rather than digging through emails that have a limited audience. This will also keep information organized, rather than letting it all get lost in conversation (though we can still have & keep conversation for references, which is why I created the "Discussions" section).

I'm not suggesting that we replace all casual emails with this, but that any information & ideas we share or collaborate on be posted there instead of in emails, so that it can stick around and be expanded upon & discussed in an organized fashion that's easy to refer to.

Note: read the following two emails that I have copied to SomethingNew for added context:
https://github.com/d-cook/SomethingNew/blob/master/Emails/PavelDanEmail.md
https://github.com/d-cook/SomethingNew/blob/master/Emails/JoelDanEmail.md

----

John Carlson
<br/>2 November 2017

Is there a chance the live editor can be used to generate a trace or log of actions, to be used for abstraction (sequence clustering) and teaching the computer how to do things (programming by demonstration, imitation learning and one-shot imitation learning).  I do not know if this means a fully undoable environment or not, including operational transform (multiple user, parallel action).

Kind of what I mean by this is a multilevel, but probably not a meta level programming environment, at the base level, you are programming with symbols or objects, at the next level up, you are programming with actions, and at the next level above that, you are programming with undo, redo, cut and uncut, pause, play and reverse play.

At the different levels, you have a space of symbols in the live editor, a space of symbol actions in the live recorder, and a space of meta actions in the live meta recorder.

----

Dan Cook
<br/>2 November 2017

This is the kind of idea that should go into Concepts.md.

Currently, this is a list of ideas with little to no explanation. I've been thinking that we should either add descriptions and/or create separate documents for each so that they can really be described in detail. Maybe both: a list with links to separate pages?

----

John Carlson
<br/>2 November 2017

I will add it to Concepts.md and try to push.  I have previous description of a similar project, here: http://dsmforum.org/events/DSVL01/carlson.pdf I just would like to introduce it into whatever coding environments we all are working on.  It may be a background thing where logs are transferred to a central server, or it may be a client/server multiuser thing, or it may be an entirely client side thing (for privacy purposes), these are all possible, but I don’t know of anyone who has a comprehensive solution yet (but I haven’t searched).  I have seen some work on multiuser PbD, but that’s it.

----

Dan Cook
<br/>2 November 2017

Wow, this looks like a modern reboot of SmallTalk in that it allows children to assemble, code, and explore everything in the computer (software & hardware): https://kano.me/store/us/products/computer-kit. (I've added this to the "projects.md" file)

----

Dan Cook
<br/>2 November 2017

*(In response to Jecel commenting about not having much to contribute to UI design)*

This is not all about UI design, and neither is it about a single software creation that we are hoping to all make together. The point is to share ideas & collaborate across multiple projects in the hopes of creating something fundamentally new.

So the question might be what kind of "new" we are looking for.

I think we have a bunch of overlapping mostly related ideas about what it's about, and everyone might give a slightly different answer; and maybe a sub-goal is to identify what we are hoping to achieve (both collectively and individually). The hope is that SomethingNew can serve as not just a place to collaborate, but also to explore what this "new" is, and identify noble goals and means & ideas to achieve them. ... And again, it's not all about UI stuff (though I'd personally say that UI is highly necessary for reinventing software in a meaningful way; but there are lots of other facets to it than that).

If I take my stab at it though, I'd say that the common theme is to build upon why Alan Kay (and Bret Victor) says about the "computer revolution" not having happened yet. That is, there are powerful new ways of thinking and doing that computers make possible; but humanity has yet to discover it because we are using it mostly as a means to do "old things" better. This can be applied at MANY levels: programming language, UI, media, networks, operating systems, etc.

Perhaps another take on it (but related) is to rethink programming and computers in better human terms, rather than the vulgar mechanical & technical ways it is all thought of and approached. A lot of this applies even just to programming languages, coding practices, and software development/engineering techniques; but we can also relate a lot of UI stuff to this as well.

I suggest that you look at the lists of resources, concepts, etc., and see what you can find in there. And if you REALLY want to investigate it (e.g. actually go read or watch things), you could spend more than a year just digesting the breadth and depth of what's been accumulated so far. (And that's another goal: programming is SO stuck in thinking about mechanism, that it is REALLY really hard for many programmers to begin to value something that involves a new way of thinking, especially if that thinking is about trading a mechanistic view for a humanistic one) ... and there are many resources I could refer you to to better explain / elaborate on what I'm saying here; so the best thing is to just go out and learn all the things that most software folk are completely blind to. It's incredible that most of us (software folk) do not truly understand what software & programming REALLY is, or the mess that it has become, or the hugeness of what is possible but has been overlooked for decades.

Anyway, even if you have nothing related to contribute, you are welcome to stick around, or learn, or share, or whatever. And if you have anything interested but not "related", feel free to email about it at least.

...

Oh, and if we DO end up coming up with one main "super software" thing, then I am sure that there are many aspects of it that are not just about the UI. There is programming language, bootstrapping, data modeling, compiler / interpreter / translator stuff, OS stuff (maybe), etc. And once such a system begins to exist, the hope is that it will be its own exploratorium for turning it into something new -- and I dont think that requires any UI experience, just tinkering and discovery.

Also, it is likely that we might approach such a system from different angles or in different ways, and these things may either come together or be explored in parallel, or possibly be able to "bootstrap" themselves into each other. Lots of possibilities, many of which I think we will not know until we get there.

----

"BGB"
<br/>3 November 2017

Some more info about my projects:

My thinking is that it could be nice to have a CPU arch and compiler infrastructure that is more accessible to individuals wanting to experiment (the existing options aren't great for this). For example, x86, while not too bad for compilers or assemblers, isn't well suited to small FPGA implementations with any real semblance of performance. likewise newer variants are highly patent encumbered (likewise goes for ARM).

A RISC style ISA can be more easily implemented on a lower-cost FPGA (eg: below $100), and can more easily (and consistently) deliver around 1 operation per clock-cycle (excluding memory accesses), which is potentially "usefully fast" (if one can get it clocked at ~ 100-200 MHz, ...).

While fixed-width is easier, 16|32 variable width at least is manageable (though, in my case, my attempt did require an additional pipeline stage vs the fixed-width case). The reason for 16 or 16|32 over just 32 bit ops is that of code density, where only a minority of ops "actually need" the full 32 bits, and using 32b for ever operation wastes space. likewise, code-density matters because I-cache isn't free. Though, a RISC with only 32-bit ops can be simpler/cleaner than one with 16-bit ops or 16|32 ops.

Pure 16-bit suffers some in not being quite sufficient to represent an entire ISA effectively, leading to a lot of ugly edge-cases; and 16|32 leads to some added redundancy (multiple variants of the same logical instruction). pure 16-bit also doesn't leave all that much space for experimentation or extensions either.

For compilers, drawbacks emerge:
* GCC is very large, slow and difficult to modify and rebuild from source;
* LLVM basically kills the computer trying to compile it.
  * Even a PC with 16 or 24 GB of RAM may still end up swapping
  * Build times of ~ 45 minutes or so are not good for iteration.
* Options like LCC, ... are typically fairly limited.
  * Many of the simple compilers are "parse to AST, flatten AST to ASM, call it done".
  * I would also prefer it to be plain C, and "relatively clean".

My C compiler, still falls short of ideal, but at least I am more familiar with the code.
Though, it seems that my approach to things is very different from many of the others I had looked at:
* Tokenizer basically splits off tokens, which are then matched by the parser afterwards.
  * Some of the others use basically huge nested switches to parse at the character level.
* I use abstract nodes with assigned/named attributes and child nodes.
  * Many of the others use GTK-style struct-casting with a large number of node-type structs.
* Most of my other structure types are "generic" and identified by tags.

The ASTs in my C compiler are generally dumped as XML (and historically the AST system was derived from DOM); but had considered moving over to a more JSON like notation (my BS2 VM also used a JSON-like external notation for its ASTs; whereas its predecessor, the BS VM, had used S-Expressions).

General AST node structure, BS2 and BGBCC:
* Consists of key/value pair-arrays, with a 16-bit key (identifies key symbol and value type);
* Value is generally a 64-bit value with a meaning that depends on the key.
  * ex: a 64 bit integer value; a double; a node-pointer; a short string; a string pointer; ...
* In BGBCC, they also hold internal linked-list stuff, whereas BS2VM used arrays.
  * I may consider trying to move BGBCC to external linking
    * Mostly to allow reducing memory use due to reducing needless tree-cloning.
    * Also to save some fields for stuff that is N/A for most nodes (eg: hash-linking)
  * Linked lists are cheaper than arrays when N is small (common in ASTs).

Possibly also unusual is its pipeline:
* preproc -> parser => AST -> frontend => RIL3A
* RIL3A -> stack-machine => 3AC/SSA -> codegen -> native => ELF|PE
Or: 
* preproc -> parser => AST -> frontend -> stack-machine =>
  * 3AC/SSA -> codegen -> native => ELF | PE/COFF

Where RIL3A is a stack-machine IR, and was used mostly because it was sort-of around as a vestigial structure, and I noted a stack IR would be a bit simpler to flatten and reload than the 3AC. Similarly, this part exists mostly because it became apparent early on that I would need some way to be able to support a statically-linked C runtime, and would prefer not to do it by always compiling the C runtime from source.

The 3AC/SSA stage is basically where the frontend/backend split happens. Both stages are basically independent, but the backend still uses the front-end for type-system. Generally, the 3AC covers the entire program image, as individual translation-units no longer exist at this stage (and are mostly just faked in the frontend to keep C happy). Things like function prototypes/structs/typedefs/... effectively merge between translation units. This can give some of the advantages of single-translation-unit, without breaking C semantics.

Though, a full "single translation unit" mode could further reduce costs by avoiding a lot of redundant preprocessing and parsing, which still remain as an issue. As noted, there is currently no use of an external assembler or linker. Use of an ASM stage and object-file stage were avoided internally partly for speed and code-size reasons.

ASM is supported, but goes like this:
* preproc -> (forwarded as a blob through other stages) -> ASM parser -> native.
* Basically, to most stages it looks like a module simply containing a big inline-assembler blob.
  * The ASM parser basically reuses a lot of structure otherwise used for emitting native code.
  * But, as a side-effect, may gain some funky pseudo-instructions.

Note that some parts of the compiler pipeline are controlled using FOURCC's, ideally it would be made more modular, such that components (such as language frontends or machine back-ends) could be added/registered more as plug-ins.

A previously considered experiment (didn't get very far though) would be to do stuff to do bare-metal programming in my BS2 language (but would need to find a good place to "bridge" between the compilers). The "probably easiest" route here would be adding logic to parse the BS2VM's bytecode (also stack based, though a bit different) and spit out 3AC in the format used by BGBCC's backend.

FWIW, generally, BS2 would present itself to the native ABI effectively as something resembling a COM interface.

Also possible, but would be a lot more effort, would be adding more backends to BGBCC (such as ARM, RISC-V, or x86). though, an Thumb or RISC-V Compressed backend probably wouldn't be too huge of a jump.

x86 would be a bigger jump as-is, but x86 is also a bit easier to write codegen's for (unlike SuperH or Thumb, things like "arithmetic op with immediate", "get constant loaded into a register" or "branch to a label over there" are not turned into a big/complicated mess).

----

Jecel Assumpcao Jr.
<br/>3 November 2017

We are near the end of a project called SiliconSqueak that is a
processor optimized for running Smalltalk (both interpreted and with
adaptive complication). We are also about to start a project to develop
a completely new computer architecture (very unlike the current Von
Neuman ones) implementing objects and message passing at the transistor
level. This also involves new languages and systems.

----

"BGB"
<br/>3 November 2017

Seems like it could be interesting.

I had been messing some with FPGA's and Verilog some recently, which are a
bit more open in terms of what one can do (and have some semblance of
efficiency).

I had noticed before that, for example, the memory blocks (LUTRAM and
Block-RAM) in a lot of the FPGA's are 18 or 36 bits wide. it seems
conceivable that this could be used, say, to implement both a
byte-oriented and tagged word memory model in the same space (with
relatively little added cost).

Granted, the external DRAM wouldn't have these extra bits, meaning
probably needing to do something fancy in the cache/memory subsystem
(and sacrificing a certain percentage of the total RAM for tag-bits).
or, less fancy, stick with untagged memory and mostly work with
type-tagged registers.

Instructions for checking type-tags, ..., could be implemented in the
ISA, which could allow for cheaper dynamically-typed languages, while
not necessarily putting a burden on more traditional statically-typed
languages.

Potentially, it could also reduce the size of the ISA slightly, because
many operators could be reused between multiple types (type being given
on load/store vs on every operation).

As for Von Neuman or not, there are advantages to it.

Most modern processors (including my own designs attempts) were
internally Modified Harvard, where code and data are kept separate
internally, but typically a shared external interface is used to RAM.
